/****************************************************************************
/* FILE:                Timeline.js                            				*/
/* DESCRIPTION:         class to represent a timeline description           */
/* VERSION:             (see git)                                       	*/
/* DATE:                (see git)                                       	*/
/* AUTHOR:              Rajiv Ramdhany <rajiv.ramdhany@bbc.co.uk>    		*/

/* Copyright 2015 British Broadcasting Corporation							*/

/* Unless required by applicable law or agreed to in writing, software		*/
/* distributed under the License is distributed on an "AS IS" BASIS,		*/
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	*/
/* See the License for the specific language governing permissions and		*/
/* limitations under the License.											*/
/****************************************************************************/

"use strict";

var redis = require("redis");

var PRIVATE = new WeakMap();

/**
 * @class Timeline
 * 
 * @classdesc A simple class to represent a timeline advertised by a device or
 * a timeline generated by a SyncController object. Instances of this class
 * can be persisted into a data store using the persistence method.
 *  
 * @constructor
 * @param {string} timelineId Identifier of this timeline
 * @param {string} sessionId This timeline's session
 * @param {string} contentId Optional identifier to associate this timeline to a contentId
 * @param {string} timelineType a timeline type identifier e.g. a URN
 * @param {string} channel address for the channel to listen to for this timeline's updates (correlation timestamps).
 * @param {string} providerId identifier of this timeline's provider (a Device or SyncController object)
 * @param {string} providerType timeline's provider type "Device" "SyncController" 
 * 
 */


/**
  * ADD timeline parent and relationship
  */
class Timeline
{
	constructor(timelineId, sessionId, contentId, timelineType, channel, providerId, providerType)
	{
		PRIVATE.set(this,{});
		var priv = PRIVATE.get(this);

		this.id = timelineId;
		this.sessionId = sessionId;
		if (typeof contentId !=="undefined")
			this.contentId = contentId; 	
		this.timelineType = timelineType;
		this.channel = channel;
		if (typeof providerId !=="undefined")
			this.providerId = providerId;
		if (typeof providerType !=="undefined")
			this.providerType = providerType;

		priv.key = "session:" + sessionId + ":timeline:" + this.id;

	}



	/**
	 * Find a timeline in the data store for this timelineId and return as a
	 * Timeline object
	 * @param {string} timelineId a timeline identifier
	 * @param {string} 
	 * @returns {Promise} a Promise object
	 */
	static getFromDataStore(timelineId, sessionId, datastore)
	{
		let key = "session:" + sessionId + ":timeline:" + timelineId;

		return new Promise((resolve, reject) =>{

			if (!(datastore instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
			
			datastore.hgetallAsync(key).then((obj)=>{
				
				if ((obj != null) && (typeof obj!=="undefined"))
				{
			
					let t = new Timeline(obj.id, obj.sessionId, obj.contentId, obj.timelineType, obj.channel, obj.providerId, obj.providerType);
					resolve(t);	
				}
				else
					resolve(null);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
	}

	/**
	 * 
	 * @param {string} timelineId a timeline identifier 
	 * @param {string} sessionId the current session's identifier
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	static existsInDataStore(timelineId, sessionId, ds)
	{

		let key = "session:" + sessionId + ":timeline:" + timelineId;

		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
			
			ds.hexistsAsync(key, "id").then((result)=>{
				
				if (typeof result!=="undefined")
				{
					if (result > 0)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});

	}


	static deleteFromDataStore(timelineId, sessionId, ds)
	{
		let key = "session:" + sessionId + ":timeline:" + timelineId;
		
		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
					
			ds.hdelAsync(key, "id", "sessionId", "timelineType", "contentId", "channel", "providerId", "providerType").then((result)=>{
						
				if (typeof result!=="undefined")
				{
					if (result >= 1)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
		
	}


	/**
	 * Sort callback function to pass to sort() method of an array
	 * @param {Timeline} a 
	 * @param {Timeline} b 
	 */
	static sortFunction(a, b)
	{
		if ((a instanceof Timeline) && (b instanceof Timeline))
		{
			return new String(a.id).localeCompare(b.id);
		}else if ((a instanceof Timeline) && (typeof b === "string"))
		{
			return new String(a.id).localeCompare(b);
		}else if ((b instanceof Timeline) && (typeof a === "string"))
		{
			return new String(b.id).localeCompare(a);
		}else if ( (typeof a === "string") && (typeof b === "string"))
		{
			return new String(a).localeCompare(b);
		}
		else
		{
			throw new Error("Incompatible types submitted to sortfunction");
		}
	}


	/**
	 * Get this object's key used for storage.
	 */
	get key()
	{
		var priv = PRIVATE.get(this);
		return priv.key;
	}

	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	persist(ds)
	{
		if ((typeof ds === undefined) || (!(ds instanceof redis.RedisClient)))
			throw new Error("Invalid data store object");
		
		// console.log("key:", this.key, " value: ", this.serialise());

		ds.hmset(this.key, this.serialise(), function(err, reply) {
			// reply is null when the key is missing
			console.log("Timeline persist err: ", err, " ,reply: ", reply );

		});
	}


	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which returns true once the data persistence has successfully
	 * completed.
	 */
	persistAsync(ds)
	{
		return new Promise((resolve, reject) =>{

			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");

			ds.hmsetAsync(this.key, this.serialise())
				.then((reply)=>{

					if (reply === "OK")
						resolve(true);
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Deletes this timeline object from the datastore
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which resolves to true once the key for this timeline
	 * has been successfully deleted from the datastore. If the promise object resolves to false, then this
	 * Timeline object was not found in the datastore
	 */
	cleanUp(ds)
	{
		var self = this;
		return new Promise((resolve, reject) =>{
			
			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");
			
			ds.hdelAsync(self.key, "id", "sessionId", "timelineType", "contentId", "channel", "providerId", "providerType")
				.then((reply)=>{
					if (reply >= 1)
					{
						console.log("Deleted timeline ", self.id, " from datastore.");
						resolve(true);
					}						
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Checks a timeline object for equality
	 * @param {Timeline} anotherObj 
	 */
	equals(anotherObj)
	{
		if (!(anotherObj instanceof Timeline))
			return false;
		
		if (anotherObj.id === this.id &&
			anotherObj.providerId === this.providerId &&
			anotherObj.timelineType === this.timelineType &&
			anotherObj.channel === this.channel)
			return true;
		
		return false;
	}

	/**
	 * Checks a timeline object for equivalency.
	 * A timeline is equivalent if it is associated with the same 
	 * contentId and is of the same type, but it can be advertised
	 * by another provider.
	 * @param {Timeline} aTimeline 
	 */
	isEquivalent(aTimeline)
	{
		if (!(aTimeline instanceof Timeline))
			return false;
	
		if (aTimeline.id === this.id &&
			aTimeline.contentId === this.contentId &&
			aTimeline.timelineType === this.timelineType)
			return true;
	}

	/**
	 * Return an array representation of this object
	 */
	serialise()
	{
		
		return this.toArray();
	
	}

	/**
	 * Return a string representation of this object
	 */
	toJSON()
	{
		let obj = { id: this.id, 
			sessionId : this.sessionId,
			timelineType : this.timelineType,
			contentId : this.contentId,
			channel : this.channel,
			providerId : this.providerId,
			providerType : this.providerType
		};
		
		return JSON.stringify(obj);	
	}

	toArray()
	{

		var array = [];

		array[0] = "id";
		array[1] = this.id;
		array[2] = "sessionId";
		array[3] = this.sessionId;
		array[4] = "timelineType";
		array[5] = this.timelineType;
		array[6] = "contentId";
		array[7] = this.contentId;
		array[8] = "channel";
		array[9] = this.channel;
		array[10] = "providerId";
		array[11] = this.providerId;
		array[12] = "providerType";
		array[13] = this.providerType;


		return array;
	}


	getInfo()
	{
		return {timelineId: this.id, 
			timelineType: this.timelineType,
			contentId: this.contentId,
			providerId: this.providerId,
			providerType: this.providerType,
			providerChannel: this.channel
		};
	}
}

	
module.exports = Timeline;