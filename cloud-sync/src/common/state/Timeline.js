
/****************************************************************************
/* FILE:                Timeline.js                            				*/
/* DESCRIPTION:         class to represent a timeline 			           */
/* VERSION:             (see git)                                       	*/
/* DATE:                (see git)                                       	*/
/* AUTHOR:              Rajiv Ramdhany <rajiv.ramdhany@bbc.co.uk>    		*/

/* Copyright 2015 British Broadcasting Corporation							*/

/* Unless required by applicable law or agreed to in writing, software		*/
/* distributed under the License is distributed on an "AS IS" BASIS,		*/
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	*/
/* See the License for the specific language governing permissions and		*/
/* limitations under the License.											*/
/****************************************************************************/


var redis = require("redis");
// const uuidv4 = require("uuid/v4");
// var SyncEvents = require("../events/syncevents_pb");
// var RedisSMQConfig = require("../events/RedisSMQConfig");
// const Producer = require("redis-smq").Producer;
var Logger = require("../logger/logger");
var log_level = "development"; 
var logger  = Logger.getNewInstance(log_level);

var PRIVATE = new WeakMap();

/**
 * @class Timeline
 * 
 * @classdesc A simple class to represent a timeline advertised by a device or
 * a timeline generated by a SyncController object. Instances of this class
 * can be persisted into a data store using the persistence method.
 *  
 * @constructor
 * @param {string} timelineId Identifier of this timeline
 * @param {string} sessionId This timeline's session
 * @param {string} contentId Optional identifier to associate this timeline to a contentId
 * @param {string} timelineType a timeline type identifier e.g. a URN
 * @param {string} channel address for the channel to listen to for this timeline's updates (correlation timestamps).
 * @param {string} providerId identifier of this timeline's provider (a Device or SyncController object)
 * @param {string} providerType timeline's provider type "Device" "SyncController" 
 * @param {boolean} useForSessionSync this timeline shall be considered for synchronising the whole session by the sync controller
 * @param {boolean} writable this timeline can be changed by an external party (e.g. sync controller):
 * @param {string} parentTL parent timeline's timelineId (optional)
 * @param {object} parentTLCorr correlation relationship with parent timeline (optional)
 * @param {object} lastTimestamp last known presentation timestamp reported by timeline provider (optional)
 * 
 */

class Timeline
{
	constructor(timelineId, sessionId, contentId, timelineType, frequency, channel, 
		providerId, providerType, useForSessionSync, writable, 
		parentTL, parentTLCorr, lastTimestamp)
	{
		PRIVATE.set(this,{});
		var priv = PRIVATE.get(this);

		this.id = timelineId;
		this.sessionId = sessionId;
		if (typeof contentId !=="undefined")
			this.contentId = contentId; 	
		this.timelineType = timelineType;
		this.frequency = frequency;

		this.channel = channel;
		if (typeof providerId !=="undefined")
			this.providerId = providerId;
		if (typeof providerType !=="undefined")
			this.providerType = providerType;
		if (typeof useForSessionSync !=="undefined")
			this.useForSessionSync = useForSessionSync;


		if (typeof writable !=="undefined")
			this.writable = writable;
		if (typeof parentTL !=="undefined")
			this.parentTL = parentTL;
		
		if (typeof parentTLCorr !=="undefined")
			this.parentTLCorr = parentTLCorr;


		if (typeof lastTimestamp !=="undefined"){
			if (lastTimestamp.contentTime === "undefined")
				throw "Invalid lastTimestamp parameter";

			this.lastTimestamp = lastTimestamp;
			this.state = "available";
			this.available = true;
		}else
		{
			this.state = "initialised";
			this.available = false;
		}

		this.createdOn = new Date();

		priv.key = "session:" + sessionId + ":timeline:" + this.id;

	}

	// --------------------------------------------------------------------------

	/**
	 * Find a timeline in the data store for this timelineId and return as a
	 * Timeline object
	 * @param {string} timelineId a timeline identifier
	 * @param {string}  sessionId
	 * @returns {Promise} a Promise object
	 */
	static getFromDataStore(timelineId, sessionId, datastore)
	{
		let key = "session:" + sessionId + ":timeline:" + timelineId;

		if (!(datastore instanceof redis.RedisClient))
			throw("data store object is not a RedisClient instance");

		return Timeline.deserialise(key, datastore);
	}


	// --------------------------------------------------------------------------

	/**
	 * 
	 * @param {string} timelineId a timeline identifier 
	 * @param {string} sessionId the current session's identifier
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	static existsInDataStore(timelineId, sessionId, ds)
	{
		if (typeof logger === "undefined")
			logger = Logger.getNewInstance();
			
		let key = "session:" + sessionId + ":timeline:" + timelineId;

		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
			
			ds.hexistsAsync(key, "id").then((result)=>{
				
				if (typeof result!=="undefined")
				{
					if (result > 0)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});

	}


	static deleteFromDataStore(timelineId, sessionId, ds)
	{
		if (typeof logger === "undefined")
			logger = Logger.getNewInstance();

		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");

			Timeline.getFromDataStore(timelineId, sessionId, ds).then((timeline) =>{

				// if (timeline!==null)
				// {
				// 	if ((typeof timeline.useForSessionSync != "undefined") && (timeline.useForSessionSync == true))
				// 	{
				// 		timeline.sendDelTimelineEventToQueue(ds, kSyncControllerQueueKey);
				// 	}
				// }
				
			}).then(()=>{
				var key = "session:" + sessionId + ":timeline:" + timelineId;
				return ds.hdelAsync(key, "id", "sessionId", "timelineType", "contentId", "frequency","channel", "providerId", "providerType",
					"useForSessionSync", "writable", "parentTL", "parentTLCorr", "lastTimestamp", "createdOn");

			}).then((result)=>{
				logger.debug("deleteFromDataStore(): timelines deleted: ", result);			
				if (typeof result!=="undefined")
				{
					if (result >= 1)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
	}

	

	static storageKey(timelineId, sessionId)
	{
		return "session:" + sessionId + ":timeline:" + timelineId;
	}


	/**
	 * Get this object's key used for storage.
	 */
	get key()
	{
		var priv = PRIVATE.get(this);
		return priv.key;
	}

	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	persist(ds)
	{
		var self = this;
		if ((typeof ds === undefined) || (!(ds instanceof redis.RedisClient)))
			throw new Error("Invalid data store object");
		
		ds.hmset(this.serialise(), function(err, reply) {

			logger.debug("Timeline " , self.id, " saved : ", reply);
		});
	}


	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which returns true once the data persistence has successfully
	 * completed.
	 */
	persistAsync(ds)
	{
		var self = this;
		return new Promise((resolve, reject) =>{

			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");

			ds.hmsetAsync(self.serialise())
				.then((reply)=>{

					if (reply === "OK")
						resolve(true);
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Deletes this timeline object from the datastore
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which resolves to true once the key for this timeline
	 * has been successfully deleted from the datastore. If the promise object resolves to false, then this
	 * Timeline object was not found in the datastore
	 */
	cleanUp(ds)
	{
		var self = this;
		return new Promise((resolve, reject) =>{
			
			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");

			// if ((typeof self.useForSessionSync != "undefined") && (self.useForSessionSync == true))
			// {
			// 	self.sendDelTimelineEventToQueue.call(self, ds, kSyncControllerQueueKey);
			// }
			
			ds.hdelAsync(self.key, "id", "sessionId", "timelineType", "contentId", "frequency","channel", "providerId", "providerType",
				"useForSessionSync", "writable", "parentTL", "parentTLCorr", "lastTimestamp", "createdOn")
				.then((reply)=>{
					if (reply >= 1)
					{
						logger.debug("Deleted timeline ", self.id, " from datastore.");
						resolve(true);
					}						
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Checks a timeline object for equality
	 * @param {Timeline} anotherObj 
	 */
	equals(anotherObj)
	{
		if (!(anotherObj instanceof Timeline))
			return false;
		
		if (anotherObj.id === this.id &&
			anotherObj.providerId === this.providerId &&
			anotherObj.timelineType === this.timelineType &&
			anotherObj.channel === this.channel)
			return true;
		
		return false;
	}

	/**
	 * Checks a timeline object for equivalency.
	 * A timeline is equivalent if it is associated with the same 
	 * contentId and is of the same type, but it can be advertised
	 * by another provider.
	 * @param {Timeline} aTimeline 
	 */
	isEquivalent(aTimeline)
	{
		if (!(aTimeline instanceof Timeline))
			return false;
	
		if (aTimeline.contentId === this.contentId &&
			aTimeline.timelineType === this.timelineType)
			return true;
	}

	/**
	 * Return an array representation of this object
	 */
	serialise()
	{
		return this.toArray();	
	}

	/**
	 * Deserialise Timeline object from Redis
	 * @param {String} key 
	 * @param {RedisClient} datastore 
	 */
	static deserialise(key, datastore)
	{
		return new Promise((resolve, reject) =>{
			datastore.hgetallAsync(key).then((obj)=>{
				
				if ((obj != null) && (typeof obj!=="undefined"))
				{
					
					let t = new Timeline(obj.id, obj.sessionId, obj.contentId, obj.timelineType, obj.frequency, 
						obj.channel, obj.providerId, obj.providerType, obj.useForSessionSync, obj.writable);
	
					if (typeof obj.parentTL !=="undefined")
						t.parentTL = obj.parentTL;
					
					if (typeof obj.parentTLCorr !=="undefined"){
						if (typeof obj.parentTLCorr ==="string")
							t.parentTLCorr = JSON.parse(obj.parentTLCorr);
						else
							t.parentTLCorr = obj.parentTLCorr;
					}
					
					if (typeof obj.lastTimestamp !=="undefined"){
	
						if (typeof obj.lastTimestamp ==="string")
							t.lastTimestamp = JSON.parse(obj.lastTimestamp);
						else
							t.lastTimestamp = obj.lastTimestamp;						
					}
					if (typeof obj.state !=="undefined"){
						t.state = obj.state;						
					}
					if (typeof obj.available !=="undefined"){
						t.available = obj.available;						
					}

					if (typeof obj.createdOn !=="undefined"){
						t.createdOn = new Date(obj.createdOn);						
					}
					// console.log("Timeline.getFromDataStore():");	
					// console.log(t);
						
					resolve(t);	
				}
				else
					resolve(null);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
		
		
	}

	getInfo()
	{
		
		
		let obj = {timelineId: this.id, 
			sessionId : this.sessionId,
			timelineType: this.timelineType,
			frequency: this.frequency,
			contentId: this.contentId,
			channel: this.channel,
			providerId: this.providerId,
			providerType: this.providerType,
			useForSessionSync: this.useForSessionSync,
			writable: this.writable,
			available: this.available,
			createdOn: this.createdOn
		};

		if (typeof this.parentTL !== "undefined")
		{
			obj.parentTL = this.parentTL;
		}

		if (typeof this.parentTLCorr !== "undefined")
		{
			obj.parentTLCorr =this.parentTLCorr;
		}

		if (typeof this.lastTimestamp !== "undefined")
		{
			obj.lastTimestamp = this.lastTimestamp;
		}


		return obj;
	}

	/**
	 * Return a string representation of this object
	 */
	toJSON()
	{
		let obj = { id: this.id, 
			sessionId : this.sessionId,
			timelineType : this.timelineType,
			frequency: this.frequency,
			contentId : this.contentId,
			channel : this.channel,
			providerId : this.providerId,
			providerType : this.providerType,
			useForSessionSync: this.useForSessionSync,
			writable: this.writable,
			available: this.available,
			createdOn: this.createdOn.toISOString()
		};
		
		// parentTL, parentTLCorr, lastTimestamp, state, available
		if (typeof this.parentTL !== "undefined")
		{
			obj.parentTL = this.parentTL;
		}

		if (typeof this.parentTLCorr !== "undefined")
		{
			if (typeof this.parentTLCorr === "string"){
				obj.parentTLCorr = this.parentTLCorr;
			}else
			{
				obj.parentTLCorr = JSON.stringify(this.parentTLCorr);
			}			
		}

		if (typeof this.lastTimestamp !== "undefined")
		{
			obj.lastTimestamp = JSON.stringify(this.lastTimestamp);
		}

		if (typeof this.state !== "undefined")
		{
			obj.state = this.state;
		}


		return JSON.stringify(obj);	
	}

	/** 
	 * Flatten object to array representation
	*/
	toArray()
	{
		var priv = PRIVATE.get(this);
		var array = [];

		array[0] = priv.key;
		array[1] = "id";
		array[2] = this.id;
		array[3] = "sessionId";
		array[4] = this.sessionId;
		array[5] = "timelineType";
		array[6] = this.timelineType;
		array[7] = "contentId";
		array[8] = this.contentId;
		array[9] = "channel";
		array[10] = this.channel;
		array[11] = "providerId";
		array[12] = this.providerId;
		array[13] = "providerType";
		array[14] = this.providerType;
		array[15] = "useForSessionSync";
		array[16] = this.useForSessionSync;
		array[17] = "writable";
		array[18] = this.writable;
		array[17] = "available";
		array[18] = this.available;
		array[19] = "frequency";
		array[20] = this.frequency;

		var index = 20;

		if (typeof this.parentTL !== "undefined")
		{
			array[++index] = "parentTL";
			array[++index] = this.parentTL;
		}

		if (typeof this.parentTLCorr !== "undefined")
		{
			array[++index] = "parentTLCorr";
			if (typeof this.parentTLCorr === "string"){
				array[++index] = this.parentTLCorr;
			}else
			{
				array[++index] = JSON.stringify(this.parentTLCorr);
			}			
		}

		if (typeof this.lastTimestamp !== "undefined")
		{
			array[++index] = "lastTimestamp";
			array[++index] = JSON.stringify(this.lastTimestamp);
		}

		if (typeof this.state !== "undefined")
		{
			array[++index] = "state";
			array[++index] = this.state;
		}

		array[++index] = "createdOn";
		array[++index] = this.createdOn.toISOString();
				
		return array;

	}

	/**
	 * 
	 * @param {object} timestamp Correlation timestamp e.g. {wallclockTime: 242424,  contentTime:4224, speed:1.0}
	 * @param {int} thresholdMS threshold for timeline change to be considered significant
	 */
	isSignificantChange(newtimestamp, thresholdMS, parentTLFreq)
	{
		
		var wc_freq= parentTLFreq || 1e3; 
		var thresh_ms = thresholdMS || 20;

		if ((typeof this.lastTimestamp === "undefined") && (typeof newtimestamp !== "undefined"))
			return true;
		
		if ((typeof this.lastTimestamp.speed === "undefined") || (typeof newtimestamp.speed === "undefined"))
		{
			logger.error("Missing speed property in timestamp object");
			throw new Error("Missing speed property in timestamp object");
		}	
		
		if (this.lastTimestamp.speed !== newtimestamp.speed)
			return true;
		
		// calculate timeline position at wallclock-time in newtimestamp

		var expectedTimelinePos =  (newtimestamp.wallclockTime - this.lastTimestamp.wallclockTime) * this.lastTimestamp.speed * this.frequency / wc_freq + this.lastTimestamp.contentTime;

		if (Math.abs(newtimestamp.contentTime - expectedTimelinePos) > thresh_ms)
			return true;

	}


}


function parseBoolean(string)
{
	var bool;
	bool = (function() {
		switch (false) {
		case string.toLowerCase() !== "true":
			return true;
		case string.toLowerCase() !== "false":
			return false;
		}
	})();
	if (typeof bool === "boolean") {
		return bool;
	}
	return void 0;
}
	
module.exports = Timeline;