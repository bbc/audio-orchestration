
/****************************************************************************
/* FILE:                Timeline.js                            				*/
/* DESCRIPTION:         class to represent a timeline description           */
/* VERSION:             (see git)                                       	*/
/* DATE:                (see git)                                       	*/
/* AUTHOR:              Rajiv Ramdhany <rajiv.ramdhany@bbc.co.uk>    		*/

/* Copyright 2015 British Broadcasting Corporation							*/

/* Unless required by applicable law or agreed to in writing, software		*/
/* distributed under the License is distributed on an "AS IS" BASIS,		*/
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	*/
/* See the License for the specific language governing permissions and		*/
/* limitations under the License.											*/
/****************************************************************************/


var redis = require("redis");
var SyncEvents = require("../events/syncevents_pb");
var MessageIdGenerator = require("../message/MessageIdGenerator");
var RedisSMQConfig = require("../events/RedisSMQConfig");
const Producer = require("redis-smq").Producer;
var Logger = require("../logger/logger");
var log_level = "development"; 
var logger  = Logger.getNewInstance(log_level);

var PRIVATE = new WeakMap();

// ---------------------------------------------------------
//  Constants
// ---------------------------------------------------------
const kSyncControllerQueueKey = "cloudsync:synccontroller:waitQueue";


/**
 * @class Timeline
 * 
 * @classdesc A simple class to represent a timeline advertised by a device or
 * a timeline generated by a SyncController object. Instances of this class
 * can be persisted into a data store using the persistence method.
 *  
 * @constructor
 * @param {string} timelineId Identifier of this timeline
 * @param {string} sessionId This timeline's session
 * @param {string} contentId Optional identifier to associate this timeline to a contentId
 * @param {string} timelineType a timeline type identifier e.g. a URN
 * @param {string} channel address for the channel to listen to for this timeline's updates (correlation timestamps).
 * @param {string} providerId identifier of this timeline's provider (a Device or SyncController object)
 * @param {string} providerType timeline's provider type "Device" "SyncController" 
 * @param {boolean} useForSessionSync this timeline shall be considered for synchronising the whole session by the sync controller
 * @param {boolean} writable this timeline can be changed by an external party (e.g. sync controller):
 * 
 */


/**
  * ADD timeline parent and relationship
  */
class Timeline
{
	constructor(timelineId, sessionId, contentId, timelineType, frequency, channel, 
		providerId, providerType, useForSessionSync, writable, 
		parentTL, parentTLCorr, lastTimestamp)
	{
		PRIVATE.set(this,{});
		var priv = PRIVATE.get(this);

		this.id = timelineId;
		this.sessionId = sessionId;
		if (typeof contentId !=="undefined")
			this.contentId = contentId; 	
		this.timelineType = timelineType;
		this.frequency = frequency;

		this.channel = channel;
		if (typeof providerId !=="undefined")
			this.providerId = providerId;
		if (typeof providerType !=="undefined")
			this.providerType = providerType;
		if (typeof useForSessionSync !=="undefined")
			this.useForSessionSync = useForSessionSync;
		if (typeof writable !=="undefined")
			this.writable = writable;
		if (typeof parentTL !=="undefined")
			this.parentTL = parentTL;
		
		if (typeof parentTLCorr !=="undefined")
			this.parentTLCorr = parentTLCorr;


		if (typeof lastTimestamp !=="undefined"){
			if (lastTimestamp.contentTime === "undefined")
				throw "Invalid lastTimestamp parameter";

			this.lastTimestamp = lastTimestamp;
			this.state = "available";
			this.available = true;
		}else
		{
			this.state = "initialised";
			this.available = false;
		}
		priv.key = "session:" + sessionId + ":timeline:" + this.id;


		

	}



	/**
	 * Find a timeline in the data store for this timelineId and return as a
	 * Timeline object
	 * @param {string} timelineId a timeline identifier
	 * @param {string} 
	 * @returns {Promise} a Promise object
	 */
	static getFromDataStore(timelineId, sessionId, datastore)
	{
		let key = "session:" + sessionId + ":timeline:" + timelineId;

		return new Promise((resolve, reject) =>{

			if (!(datastore instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
			
			datastore.getAsync(key).then((result)=>{
				
				if ((result != null) && (typeof result!=="undefined"))
				{

					let obj = JSON.parse(result);

					
					let t = new Timeline(obj.id, obj.sessionId, obj.contentId, obj.timelineType, obj.frequency, 
						obj.channel, obj.providerId, obj.providerType, obj.useForSessionSync, obj.writable);

					if (typeof obj.parentTL !=="undefined")
						t.parentTL = obj.parentTL;
					
					if (typeof obj.parentTLCorr !=="undefined"){
						if (typeof obj.parentTLCorr ==="string")
							t.parentTLCorr = JSON.parse(obj.parentTLCorr);
						else
							t.parentTLCorr = obj.parentTLCorr;
					}
					
					if (typeof obj.lastTimestamp !=="undefined"){

						if (typeof obj.lastTimestamp ==="string")
							t.lastTimestamp = JSON.parse(obj.lastTimestamp);
						else
							t.lastTimestamp = obj.lastTimestamp;						
					}
					if (typeof obj.state !=="undefined"){
						t.state = obj.state;						
					}
					if (typeof obj.available !=="undefined"){
						t.available = obj.available;						
					}
					// console.log("Timeline.getFromDataStore():");	
					// console.log(t);
						
					resolve(t);	
				}
				else
					resolve(null);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
	}

	/**
	 * 
	 * @param {string} timelineId a timeline identifier 
	 * @param {string} sessionId the current session's identifier
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	static existsInDataStore(timelineId, sessionId, ds)
	{
		if (typeof logger === "undefined")
			logger = Logger.getNewInstance();
			
		let key = "session:" + sessionId + ":timeline:" + timelineId;

		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");
			
			ds.existsAsync(key).then((result)=>{
				
				if (typeof result!=="undefined")
				{
					if (result > 0)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});

	}


	static deleteFromDataStore(timelineId, sessionId, ds)
	{
		if (typeof logger === "undefined")
			logger = Logger.getNewInstance();

		return new Promise((resolve, reject) =>{
			if (!(ds instanceof redis.RedisClient))
				reject("data store object is not a RedisClient instance");

			Timeline.getFromDataStore(timelineId, sessionId, ds).then((timeline) =>{

				if (timeline!==null)
				{
					if ((typeof timeline.useForSessionSync != "undefined") && (timeline.useForSessionSync == true))
					{
						timeline.sendDelTimelineEventToQueue(ds, kSyncControllerQueueKey);
					}
				}
				
			}).then(()=>{
				var key = "session:" + sessionId + ":timeline:" + timelineId;
				return ds.delAsync(key);
			}).then((result)=>{
				logger.debug("deleteFromDataStore(): timelines deleted: ", result);			
				if (typeof result!=="undefined")
				{
					if (result >= 1)
						resolve(true);	
					else
						resolve(false);
				}
				else
					reject(false);
			}).catch((datastore_reply) =>{
				reject(datastore_reply);
			});
		});
	}

	/**
	 * 
	 * @param {Object} ds a connected data store client e.g a redis-client 
	 * @param {String} queue queue name
	 */
	sendDelTimelineEventToQueue(ds, queue)
	{
		if (typeof logger === "undefined")
			logger = Logger.getNewInstance();
		var self = this;
		
		var evhdr = new proto.Header();
		evhdr.setEventtype(proto.EventType.DEL_SYNC_TIMELINE);
		evhdr.setSessionid(this.sessionId);
		evhdr.setSenderid(this.providerId);
		evhdr.setVersion("1.0");
		evhdr.setEventid(MessageIdGenerator.getNewId());
		var evBody= new proto.DelSyncTLEvent();
		evBody.setTimelineid(this.id);   
		var evBodyBytes = evBody.serializeBinary();

		var event = new proto.SyncEvent();
		event.setHeader(evhdr);
		event.setBody(evBodyBytes); 
		var eventBytes = event.serializeBinary();
		var eventBytesString = ab2str(eventBytes);
		
		if (typeof this.syncCrtlQProducer === "undefined")
		{
			logger.debug("sendDelTimelineEventToQueue(): instantiating new redis-smq producer.");
			self.redissmqConfig = new RedisSMQConfig(ds.connection_options.host, ds.connection_options.port);
			self.syncCrtlQProducer = new Producer(queue, self.redissmqConfig.getConfig());

			self.syncCrtlQProducer.produceWithTTL({event: eventBytesString}, 60000, (err) => {
				if (err) throw err;
				logger.debug("sendDelTimelineEventToQueue(): Dispatched Timeline_Deleted event to SyncController, for timeline: %s ", this.id);
				self.syncCrtlQProducer.shutdown();		    
			});

		}else
		{
			self.syncCrtlQProducer.produceWithTTL({event: eventBytesString}, 60000, (err) => {
				if (err) throw err;
				logger.debug("sendDelTimelineEventToQueue(): Enqueued SyncController event: %s ", eventBytesString);
			});
		} 
	}



	/**
	 * Sort callback function to pass to sort() method of an array
	 * @param {Timeline} a 
	 * @param {Timeline} b 
	 */
	static sortFunction(a, b)
	{
		if ((a instanceof Timeline) && (b instanceof Timeline))
		{
			return new String(a.id).localeCompare(b.id);
		}else if ((a instanceof Timeline) && (typeof b === "string"))
		{
			return new String(a.id).localeCompare(b);
		}else if ((b instanceof Timeline) && (typeof a === "string"))
		{
			return new String(b.id).localeCompare(a);
		}else if ( (typeof a === "string") && (typeof b === "string"))
		{
			return new String(a).localeCompare(b);
		}
		else
		{
			throw new Error("Incompatible types submitted to sortfunction");
		}
	}


	/**
	 * Get this object's key used for storage.
	 */
	get key()
	{
		var priv = PRIVATE.get(this);
		return priv.key;
	}

	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 */
	persist(ds)
	{
		if ((typeof ds === undefined) || (!(ds instanceof redis.RedisClient)))
			throw new Error("Invalid data store object");
		
		ds.set(this.key, this.serialise(), function(err, reply) {
			// reply is null when the key is missing
			// console.log("Timeline persist reply: " + reply);
		});
	}


	/**
	 * Persist this object to a Redis datastore.
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which returns true once the data persistence has successfully
	 * completed.
	 */
	persistAsync(ds)
	{
		return new Promise((resolve, reject) =>{

			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");

			ds.setAsync(this.key, this.serialise())
				.then((reply)=>{

					if (reply === "OK")
						resolve(true);
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Deletes this timeline object from the datastore
	 * @param {RedisClient} ds a redis client object created using {@link https://www.npmjs.com/package/redis|redis} library 
	 * @returns {Promise} a Promise object which resolves to true once the key for this timeline
	 * has been successfully deleted from the datastore. If the promise object resolves to false, then this
	 * Timeline object was not found in the datastore
	 */
	cleanUp(ds)
	{
		var self = this;
		return new Promise((resolve, reject) =>{
			
			if ((typeof ds === undefined) && (!(ds instanceof redis.RedisClient)))
				reject("Invalid data store object");

			if ((typeof self.useForSessionSync != "undefined") && (self.useForSessionSync == true))
			{
				self.sendDelTimelineEventToQueue.call(self, ds, kSyncControllerQueueKey);
			}
			
			ds.delAsync(self.key)
				.then((reply)=>{
					if (reply >= 1)
					{
						logger.debug("Deleted timeline ", self.id, " from datastore.");
						resolve(true);
					}						
					else
						resolve(false);
				})
				.catch((error) =>{
					reject(error);
				});
		});
	}

	/**
	 * Checks a timeline object for equality
	 * @param {Timeline} anotherObj 
	 */
	equals(anotherObj)
	{
		if (!(anotherObj instanceof Timeline))
			return false;
		
		if (anotherObj.id === this.id &&
			anotherObj.providerId === this.providerId &&
			anotherObj.timelineType === this.timelineType &&
			anotherObj.channel === this.channel)
			return true;
		
		return false;
	}

	/**
	 * Checks a timeline object for equivalency.
	 * A timeline is equivalent if it is associated with the same 
	 * contentId and is of the same type, but it can be advertised
	 * by another provider.
	 * @param {Timeline} aTimeline 
	 */
	isEquivalent(aTimeline)
	{
		if (!(aTimeline instanceof Timeline))
			return false;
	
		if (aTimeline.id === this.id &&
			aTimeline.contentId === this.contentId &&
			aTimeline.timelineType === this.timelineType)
			return true;
	}

	/**
	 * Return an array representation of this object
	 */
	serialise()
	{
		return this.toJSON();
	
	}

	/**
	 * Return a string representation of this object
	 */
	toJSON()
	{
		let obj = { id: this.id, 
			sessionId : this.sessionId,
			timelineType : this.timelineType,
			frequency: this.frequency,
			contentId : this.contentId,
			channel : this.channel,
			providerId : this.providerId,
			providerType : this.providerType,
			useForSessionSync: this.useForSessionSync,
			writable: this.writable,
			available: this.available
		};
		
		// parentTL, parentTLCorr, lastTimestamp, state, available
		if (typeof this.parentTL !== "undefined")
		{
			obj.parentTL = this.parentTL;
		}

		if (typeof this.parentTLCorr !== "undefined")
		{
			if (typeof this.parentTLCorr === "string"){
				obj.parentTLCorr = this.parentTLCorr;
			}else
			{
				obj.parentTLCorr = JSON.stringify(this.parentTLCorr);
			}			
		}

		if (typeof this.lastTimestamp !== "undefined")
		{
			obj.lastTimestamp = JSON.stringify(this.lastTimestamp);
		}

		if (typeof this.state !== "undefined")
		{
			obj.state = this.state;
		}


		return JSON.stringify(obj);	
	}

	toArray()
	{
		var priv = PRIVATE.get(this);
		var array = [];

		array[0] = priv.key;
		array[1] = "id";
		array[2] = this.id;
		array[3] = "sessionId";
		array[4] = this.sessionId;
		array[5] = "timelineType";
		array[6] = this.timelineType;
		array[7] = "contentId";
		array[8] = this.contentId;
		array[9] = "channel";
		array[10] = this.channel;
		array[11] = "providerId";
		array[12] = this.providerId;
		array[13] = "providerType";
		array[14] = this.providerType;
		array[15] = "useForSessionSync";
		array[16] = this.useForSessionSync;
		array[17] = "writable";
		array[18] = this.writable;
		array[17] = "available";
		array[18] = this.available;
		array[19] = "frequency";
		array[20] = this.frequency;

		var index = 20;

		if (typeof this.parentTL !== "undefined")
		{
			array[++index] = this.parentTL;
		}

		if (typeof this.parentTLCorr !== "undefined")
		{
			if (typeof this.parentTLCorr === "string"){
				array[++index] = this.parentTLCorr;
			}else
			{
				array[++index] = JSON.stringify(this.parentTLCorr);
			}			
		}

		if (typeof this.lastTimestamp !== "undefined")
		{
			array[++index] = JSON.stringify(this.lastTimestamp);
		}

		if (typeof this.state !== "undefined")
		{
			array[++index] = this.state;
		}
	}


	getInfo()
	{
		return {timelineId: this.id, 
			timelineType: this.timelineType,
			contentId: this.contentId,
			providerId: this.providerId,
			providerType: this.providerType,
			providerChannel: this.channel,
			useForSessionSync: this.useForSessionSync,
			writable: this.writable
		};
	}
}

function ab2str(buf) {
	return String.fromCharCode.apply(null, new Uint8Array(buf));
}

function str2ab(str) {
	var buf = new ArrayBuffer(str.length); // 2 bytes for each char
	var bufView = new Uint8Array(buf);
	for (var i=0, strLen=str.length; i < strLen; i++) {
		bufView[i] = str.charCodeAt(i);
	}
	return bufView;
}

	
module.exports = Timeline;