const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const ENCODE_CODEC = 'libfdk_aac';
const ENCODE_BITRATE = '320k';
const BUFFER_EXTENSION = 'm4a';
const SEGMENT_DURATION = 4.0;

const args = {
  inputPathSequence: process.argv[2],
  inputPath: process.argv[3],
  outputPath: process.argv[4],
};

function usage() {
  process.stdout.write('node encode-media.js sequence inputPath outputPath\n\n');
  process.stdout.write('* sequence\t\t path to json file produced by generate-sequence tool\n');
  process.stdout.write('* inputPath\t\t base path for .wav source files referenced by sequence items\n');
  process.stdout.write('* outputPath\t\t base path for storing encoded media\n');
  process.exit(1);
}

if (args.inputPathSequence === undefined) {
  console.error('input path not defined, use path to sequence.json generated by ../generate-sequence');
  usage();
}

if (args.inputPath === undefined) {
  console.error('input path not defined');
  usage();
}

if (args.outputPath === undefined) {
  console.error('output path not defined');
  usage();
}

const sequenceData = JSON.parse(fs.readFileSync(args.inputPathSequence));

function encodeBuffer(inputName, inputPath, outputPath) {
  const input = path.join(inputPath, inputName);
  const outputName = `${path.basename(inputName, '.wav')}.${BUFFER_EXTENSION}`;
  const output = path.join(outputPath, outputName);

  spawnSync('ffmpeg', [
    '-loglevel', 'warning',
    '-hide_banner',
    '-y',
    '-i', input,
    '-c:a', ENCODE_CODEC,
    '-b:a', ENCODE_BITRATE,
    output,
  ], {
    stdio: 'inherit',
  });

  return outputName;
}

function encodeDash(inputName, inputPath, outputPath) {
  const input = path.join(inputPath, inputName);
  const outputName = path.join(path.basename(inputName, '.wav'), `${path.basename(inputName, '.wav')}.mpd`);
  const output = path.join(outputPath, outputName);
  if (!fs.existsSync(output)) {
    fs.mkdirSync(path.dirname(output));
  }

  spawnSync('ffmpeg', [
    '-loglevel', 'warning',
    '-hide_banner',
    '-y',
    '-i', input,
    '-c:a', ENCODE_CODEC,
    '-b:a', ENCODE_BITRATE,
    '-use_template', 1,
    '-min_seg_duration', 1.0e6 * SEGMENT_DURATION,
    '-f', 'dash',
    output,
  ], {
    stdio: 'inherit',
  });

  return outputName;
}

sequenceData.objects = sequenceData.objects.map(object => Object.assign({}, object, {
  items: object.items.map((item) => {
    let url = null;
    if (item.source.type === 'dash') {
      url = encodeDash(item.source.url, args.inputPath, args.outputPath);
    } else if (item.source.type === 'buffer') {
      url = encodeBuffer(item.source.url, args.inputPath, args.outputPath);
    }

    return Object.assign({}, item, {
      source: Object.assign({}, item.source, {
        url,
      }),
    });
  }),
}));

process.stdout.write(JSON.stringify(sequenceData, null, 2));
