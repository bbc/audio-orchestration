const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const ENCODE_CODEC = 'libfdk_aac';
const ENCODE_BITRATE = '128k';
const BUFFER_EXTENSION = 'm4a';
const SEGMENT_DURATION = 4.0;
const SILENCE_PATH = 'silence.wav';

const args = {
  inputPathSequence: process.argv[2],
  inputPath: process.argv[3],
  outputPath: process.argv[4],
};

function usage() {
  process.stdout.write('node encode-media.js sequence inputPath outputPath\n\n');
  process.stdout.write('* sequence\t\t path to json file produced by generate-sequence tool\n');
  process.stdout.write('* inputPath\t\t base path for .wav source files referenced by sequence items\n');
  process.stdout.write('* outputPath\t\t base path for storing encoded media\n');
  process.exit(1);
}

if (args.inputPathSequence === undefined) {
  console.error('input path not defined, use path to sequence.json generated by ../generate-sequence');
  usage();
}

if (args.inputPath === undefined) {
  console.error('input path not defined');
  usage();
}

if (args.outputPath === undefined) {
  console.error('output path not defined');
  usage();
}

const sequenceData = JSON.parse(fs.readFileSync(args.inputPathSequence));

function encodeBuffer(inputName, inputPath, outputPath) {
  const input = path.join(inputPath, inputName);
  const outputName = `${path.basename(inputName, '.wav')}.${BUFFER_EXTENSION}`;
  const output = path.join(outputPath, outputName);

  const cmdArgs = [
    '-loglevel', 'warning',
    '-hide_banner',
    '-y',
    '-i', input,
    '-c:a', ENCODE_CODEC,
    '-b:a', ENCODE_BITRATE,
    output,
  ];
  console.debug('ffmpeg', cmdArgs.join(' '));
  spawnSync('ffmpeg', cmdArgs, { stdio: 'inherit' });

  return outputName;
}

function encodeDash(inputName, inputPath, outputPath, silencePath = null) {
  const input = path.join(inputPath, inputName);
  const outputName = path.join(path.basename(inputName, '.wav'), `${path.basename(inputName, '.wav')}.mpd`);
  const output = path.join(outputPath, outputName);
  if (!fs.existsSync(output)) {
    fs.mkdirSync(path.dirname(output));
  }

  const inputArgs = [
    '-loglevel', 'warning',
    '-hide_banner',
    '-y',
    '-i', input,
  ];

  const silenceArgs = [
    '-i',
    silencePath,
    '-filter_complex',
    '[0:a] concat=n=2:v=0:a=1',
  ];

  const outputArgs = [
    '-c:a', ENCODE_CODEC,
    '-b:a', ENCODE_BITRATE,
    '-use_template', 1,
    '-use_timeline', 0,
    '-min_seg_duration', 1.0e6 * SEGMENT_DURATION,
    '-hls_playlist', '1',
    '-f', 'dash',
    output,
  ];

  const cmdArgs = [].concat(
    inputArgs,
    silencePath !== null ? silenceArgs : [],
    outputArgs,
  );

  console.debug('ffmpeg', cmdArgs.join(' '));
  spawnSync('ffmpeg', cmdArgs, { stdio: 'inherit' });

  return outputName;
}

spawnSync('ffmpeg', [
  '-hide_banner',
  '-loglevel', 'warning',
  '-y',
  '-f', 'lavfi',
  '-i', 'anullsrc=r=48000:cl=1',
  '-t', SEGMENT_DURATION,
  SILENCE_PATH,
], { stdio: 'inherit' });

sequenceData.objects = sequenceData.objects.map(object => Object.assign({}, object, {
  items: object.items.map((item) => {
    let url = null;
    if (item.source.type === 'dash') {
      url = encodeDash(item.source.url, args.inputPath, args.outputPath, SILENCE_PATH);
    } else if (item.source.type === 'buffer') {
      url = encodeBuffer(item.source.url, args.inputPath, args.outputPath);
    }

    return Object.assign({}, item, {
      source: Object.assign({}, item.source, {
        url,
      }),
    });
  }),
}));

process.stdout.write(JSON.stringify(sequenceData, null, 2));
